<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JustGage Visual Diff Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }

    .comparison-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }

    .gauge-section {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      flex: 1;
    }

    .gauge-title {
      text-align: center;
      margin-bottom: 15px;
      font-weight: bold;
      color: #333;
      font-size: 16px;
    }

    .gauge-container {
      position: relative;
      display: inline-block;
      border: 2px solid #ddd;
      background: #fafafa;
    }

    .overlay-container {
      position: relative;
      display: inline-block;
    }

    .overlay-gauge {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0.5;
    }

    .controls {
      margin: 20px 0;
      text-align: center;
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .controls button {
      margin: 5px;
      padding: 8px 15px;
      background: #007cba;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #005a8b;
    }

    .controls button.active {
      background: #ff6600;
    }

    .slider-group {
      margin: 10px;
      display: inline-block;
    }

    .slider-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .slider-group input[type="range"] {
      width: 150px;
    }

    .analysis-panel {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
    }

    .diff-highlight {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid red;
      position: absolute;
      pointer-events: none;
    }

    .coordinate-display {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 1000;
    }

    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      opacity: 0.3;
    }

    #console-log {
      background: black;
      color: lime;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      height: 200px;
      overflow-y: auto;
      border-radius: 5px;
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <h1>JustGage Visual Diff Tool</h1>
  <p>Advanced visual comparison with overlay, grid, and precise positioning analysis</p>

  <div class="controls">
    <h3>Comparison Mode</h3>
    <button id="side-by-side" class="active" onclick="setMode('side-by-side')">Side by Side</button>
    <button id="overlay" onclick="setMode('overlay')">Overlay Mode</button>
    <button id="difference" onclick="setMode('difference')">Difference Highlight</button>

    <div style="margin: 15px 0;">
      <div class="slider-group">
        <label>New Gauge Opacity:</label>
        <input type="range" id="opacity-slider" min="0" max="100" value="50" oninput="adjustOpacity(this.value)">
        <span id="opacity-value">50%</span>
      </div>

      <div class="slider-group">
        <label>Test Value:</label>
        <input type="range" id="value-slider" min="0" max="100" value="67" oninput="updateValue(this.value)">
        <span id="value-display">67</span>
      </div>

      <div class="slider-group">
        <label>Min Value:</label>
        <input type="range" id="min-slider" min="-50" max="50" value="0" oninput="updateRange()">
        <span id="min-display">0</span>
      </div>

      <div class="slider-group">
        <label>Max Value:</label>
        <input type="range" id="max-slider" min="50" max="200" value="100" oninput="updateRange()">
        <span id="max-display">100</span>
      </div>
    </div>

    <h4>Gauge Configuration</h4>
    <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 10px;">
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-title" checked onchange="updateConfig()"> Title
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-label" checked onchange="updateConfig()"> Units Label
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-minmax" checked onchange="updateConfig()"> Min/Max Labels
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-pointer" onchange="updateConfig()"> Pointer
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-target" onchange="updateConfig()"> Target Line
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="donut-mode" onchange="updateConfig()"> Donut Mode
      </label>
    </div>

    <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 15px;">
      <div>
        <label>Title:</label>
        <input type="text" id="title-input" value="Test Gauge" onchange="updateConfig()" style="width: 100px;">
      </div>
      <div>
        <label>Units:</label>
        <input type="text" id="label-input" value="units" onchange="updateConfig()" style="width: 80px;">
      </div>
      <div>
        <label>Target:</label>
        <input type="number" id="target-input" value="75" min="0" max="100" onchange="updateConfig()"
          style="width: 60px;">
      </div>
      <div>
        <label>Width:</label>
        <input type="number" id="width-input" value="400" min="200" max="600" onchange="updateConfig()"
          style="width: 60px;">
      </div>
      <div>
        <label>Height:</label>
        <input type="number" id="height-input" value="320" min="150" max="500" onchange="updateConfig()"
          style="width: 60px;">
      </div>
    </div>

    <h4>Advanced Configuration</h4>
    <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 15px;">
      <div>
        <label>Gauge Color:</label>
        <input type="color" id="gauge-color" value="#e0e0e0" onchange="updateConfig()" style="width: 60px;">
      </div>
      <div>
        <label>Level Color:</label>
        <input type="color" id="level-color" value="#ff6600" onchange="updateConfig()" style="width: 60px;">
      </div>
      <div>
        <label>Pointer Color:</label>
        <input type="color" id="pointer-color" value="#8e2de2" onchange="updateConfig()" style="width: 60px;">
      </div>
      <div>
        <label>Title Font Size:</label>
        <input type="number" id="title-font-size" value="24" min="10" max="40" onchange="updateConfig()"
          style="width: 60px;">
      </div>
      <div>
        <label>Label Font Size:</label>
        <input type="number" id="label-font-size" value="11" min="8" max="20" onchange="updateConfig()"
          style="width: 60px;">
      </div>
      <div>
        <label>Gauge Width Scale:</label>
        <input type="number" id="gauge-width-scale" value="1" min="0.5" max="2" step="0.1" onchange="updateConfig()"
          style="width: 60px;">
      </div>
    </div>

    <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 10px;">
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="show-inner-shadow" onchange="updateConfig()"> Inner Shadow
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="no-gradient" onchange="updateConfig()"> No Gradient
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="reverse" onchange="updateConfig()"> Reverse
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="start-animation" checked onchange="updateConfig()"> Start Animation
      </label>
    </div>

    <div style="margin: 15px 0;">
      <button onclick="toggleGrid()">Toggle Grid</button>
      <button onclick="analyzePositions()">Analyze Positions</button>
      <button onclick="exportComparison()">Export Analysis</button>
      <button onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <div id="comparison-area">
    <div class="comparison-container">
      <div class="gauge-section">
        <div class="gauge-title">Original JustGage (Reference)</div>
        <div class="gauge-container" id="original-container">
          <div id="gauge-original"></div>
        </div>
      </div>

      <div class="gauge-section">
        <div class="gauge-title">New JustGage (Testing)</div>
        <div class="gauge-container" id="new-container">
          <div id="gauge-new"></div>
        </div>
      </div>
    </div>

    <div id="overlay-section" style="display: none;">
      <div class="gauge-section">
        <div class="gauge-title">Overlay Comparison</div>
        <div class="overlay-container" id="overlay-container">
          <div id="gauge-base"></div>
          <div id="gauge-overlay" class="overlay-gauge"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="analysis-panel">
    <h3>Position Analysis</h3>
    <div id="position-analysis"></div>
    <div id="console-log"></div>
  </div>

  <div class="coordinate-display" id="coordinate-display" style="display: none;">
    Mouse: (0, 0)
  </div>

  <!-- Original JustGage -->
  <script src="../raphael.min.js"></script>
  <script src="../justgage.js"></script>

  <!-- New JustGage -->
  <script type="module">

    // Global state
    let currentMode = 'side-by-side';
    let originalGauge, newGauge, baseGauge, overlayGauge;
    let showGrid = false;
    const OldJustGage = JustGage; // Original JustGage, prevent override when loading new

    let NewJustGage = null

    // Console logging
    const consoleLog = document.getElementById('console-log');
    const originalLog = console.log;
    console.log = function (...args) {
      originalLog.apply(console, args);
      const line = new Date().toLocaleTimeString() + ': ' + args.join(' ') + '\n';
      if (consoleLog) {
        consoleLog.textContent += line;
        consoleLog.scrollTop = consoleLog.scrollHeight;
      }
    };

    // Get current gauge parameters from UI
    function getCurrentGaugeParams() {
      const showTitle = document.getElementById('show-title').checked;
      const showLabel = document.getElementById('show-label').checked;
      const showMinMax = document.getElementById('show-minmax').checked;
      const showPointer = document.getElementById('show-pointer').checked;
      const showTarget = document.getElementById('show-target').checked;
      const donutMode = document.getElementById('donut-mode').checked;
      const showInnerShadow = document.getElementById('show-inner-shadow').checked;
      const noGradient = document.getElementById('no-gradient').checked;
      const reverse = document.getElementById('reverse').checked;
      const startAnimation = document.getElementById('start-animation').checked;

      const params = {
        value: parseInt(document.getElementById('value-display').textContent),
        min: parseInt(document.getElementById('min-display').textContent),
        max: parseInt(document.getElementById('max-display').textContent),
        width: parseInt(document.getElementById('width-input').value),
        height: parseInt(document.getElementById('height-input').value),
        gaugeColor: document.getElementById('gauge-color').value,
        levelColors: document.getElementById('level-color').value,
        titleFontSize: parseInt(document.getElementById('title-font-size').value),
        labelFontSize: parseInt(document.getElementById('label-font-size').value),
        gaugeWidthScale: parseFloat(document.getElementById('gauge-width-scale').value),
        showMinMax: showMinMax,
        donut: donutMode,
        showInnerShadow: showInnerShadow,
        noGradient: noGradient,
        reverse: reverse,
        startAnimationTime: startAnimation ? 700 : 0,
        startAnimationType: '>',
        refreshAnimationTime: 700,
        refreshAnimationType: '>'
      };

      if (showTitle) {
        params.title = document.getElementById('title-input').value;
      }

      if (showLabel) {
        params.label = document.getElementById('label-input').value;
      }

      if (showPointer) {
        params.pointer = true;
        params.pointerOptions = {
          color: document.getElementById('pointer-color').value
        };
      }

      if (showTarget) {
        params.targetLine = parseInt(document.getElementById('target-input').value);
      }

      return params;
    }        // Initialize gauges
    async function initializeGauges() {
      console.log('Initializing gauges for visual comparison...');

      try {
        // Ensure RaphaelJS is available for original gauge
        if (typeof Raphael === 'undefined') {
          console.log('❌ RaphaelJS not available for original gauge');
          return;
        }


        // Create original gauge (RaphaelJS version)
        const params = getCurrentGaugeParams();
        console.log('📊 Gauge params:', params);
        originalGauge = new OldJustGage({
          id: "gauge-original",
          ...params
        });
        console.log('✅ Original gauge created:', originalGauge);

        // Import the new JustGage implementation if not already imported
        if (!NewJustGage) {
          NewJustGage = (await import('../dist/justgage.esm.js')).JustGage;

          console.log('✅ New JustGage implementation imported');
        }

        console.log(JustGage !== NewJustGage ? '✅ Different JustGage classes confirmed' : '❌ JustGage classes are the same!');

        // Create new gauge (modern version)
        newGauge = new NewJustGage({
          parentNode: document.getElementById('gauge-new'),
          ...params
        });
        console.log('✅ New gauge created:', newGauge);

        // Create base and overlay gauges for overlay mode

        baseGauge = new OldJustGage({
          id: 'gauge-base',
          ...params
        });

        overlayGauge = new NewJustGage({
          parentNode: document.getElementById('gauge-overlay'),
          ...params
        });
        console.log('✅ Overlay gauges created');

        console.log('✅ All gauges initialized successfully');

        // Initial analysis
        setTimeout(() => analyzePositions(), 1000);

      } catch (error) {
        console.log('❌ Error initializing gauges:', error.message);
        console.log('Stack:', error.stack);
      }
    }    // Mode switching
    window.setMode = function (mode) {
      currentMode = mode;

      // Update button states
      document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
      document.getElementById(mode).classList.add('active');

      // Show/hide sections
      const comparisonContainer = document.querySelector('.comparison-container');
      const overlaySection = document.getElementById('overlay-section');

      switch (mode) {
        case 'side-by-side':
          comparisonContainer.style.display = 'flex';
          overlaySection.style.display = 'none';
          break;
        case 'overlay':
          comparisonContainer.style.display = 'none';
          overlaySection.style.display = 'block';
          break;
        case 'difference':
          comparisonContainer.style.display = 'flex';
          overlaySection.style.display = 'none';
          highlightDifferences();
          break;
      }

      console.log(`Switched to ${mode} mode`);
    };

    // Range update
    window.updateRange = function () {
      const minVal = document.getElementById('min-slider').value;
      const maxVal = document.getElementById('max-slider').value;

      document.getElementById('min-display').textContent = minVal;
      document.getElementById('max-display').textContent = maxVal;

      // Recreate gauges with new range
      recreateGauges();
    };

    // Configuration update
    window.updateConfig = async function () {
      console.log('🔄 Updating gauge configuration...');
      await recreateGauges();
    };

    // Recreate all gauges with current settings
    async function recreateGauges() {
      // Clear existing gauges
      clearGauges();

      // Recreate with new parameters
      setTimeout(async () => {
        try {
          await initializeGauges();
        } catch (error) {
          console.error('❌ Error recreating gauges:', error);
        }
      }, 100);
    }

    // Clear existing gauges
    function clearGauges() {
      console.log('🧹 Clearing existing gauges...');

      // Properly destroy gauge instances if they have destroy methods
      if (originalGauge && typeof originalGauge.destroy === 'function') {
        try {
          originalGauge.destroy();
          console.log('✅ Original gauge destroyed');
        } catch (e) {
          console.log('⚠️ Error destroying original gauge:', e);
        }
      }

      if (newGauge && typeof newGauge.destroy === 'function') {
        try {
          newGauge.destroy();
          console.log('✅ New gauge destroyed');
        } catch (e) {
          console.log('⚠️ Error destroying new gauge:', e);
        }
      }

      if (baseGauge && typeof baseGauge.destroy === 'function') {
        try {
          baseGauge.destroy();
          console.log('✅ Base gauge destroyed');
        } catch (e) {
          console.log('⚠️ Error destroying base gauge:', e);
        }
      }

      if (overlayGauge && typeof overlayGauge.destroy === 'function') {
        try {
          overlayGauge.destroy();
          console.log('✅ Overlay gauge destroyed');
        } catch (e) {
          console.log('⚠️ Error destroying overlay gauge:', e);
        }
      }

      // Clear DOM containers
      const containers = ['gauge-original', 'gauge-new', 'gauge-base', 'gauge-overlay'];
      containers.forEach(id => {
        const container = document.getElementById(id);
        if (container) {
          container.innerHTML = '';
          console.log(`✅ Cleared container: ${id}`);
        }
      });

      // Reset gauge references
      originalGauge = newGauge = baseGauge = overlayGauge = null;
      console.log('✅ All gauge references reset');
    }

    // Reset to defaults
    window.resetToDefaults = function () {
      document.getElementById('value-slider').value = 67;
      document.getElementById('min-slider').value = 0;
      document.getElementById('max-slider').value = 100;
      document.getElementById('width-input').value = 400;
      document.getElementById('height-input').value = 320;
      document.getElementById('title-input').value = 'Test Gauge';
      document.getElementById('label-input').value = 'units';
      document.getElementById('target-input').value = 75;

      document.getElementById('show-title').checked = true;
      document.getElementById('show-label').checked = true;
      document.getElementById('show-minmax').checked = true;
      document.getElementById('show-pointer').checked = false;
      document.getElementById('show-target').checked = false;
      document.getElementById('donut-mode').checked = false;

      // Update displays
      document.getElementById('value-display').textContent = '67';
      document.getElementById('min-display').textContent = '0';
      document.getElementById('max-display').textContent = '100';

      recreateGauges();
    };    // Opacity adjustment
    window.adjustOpacity = function (value) {
      document.getElementById('opacity-value').textContent = value + '%';
      const overlayGauge = document.getElementById('gauge-overlay');
      if (overlayGauge) {
        overlayGauge.style.opacity = value / 100;
      }
    };

    // Value update
    window.updateValue = function (value) {
      document.getElementById('value-display').textContent = value;

      // Update all gauges
      if (originalGauge && originalGauge.refresh) originalGauge.refresh(value);
      if (newGauge && newGauge.refresh) newGauge.refresh(value);
      if (baseGauge && baseGauge.refresh) baseGauge.refresh(value);
      if (overlayGauge && overlayGauge.refresh) overlayGauge.refresh(value);

      // Re-analyze after update
      setTimeout(() => analyzePositions(), 500);
    };

    // Grid toggle
    window.toggleGrid = function () {
      showGrid = !showGrid;
      const containers = document.querySelectorAll('.gauge-container, .overlay-container');

      containers.forEach(container => {
        let grid = container.querySelector('.grid-overlay');
        if (showGrid && !grid) {
          grid = createGrid(400, 320);
          container.appendChild(grid);
        } else if (!showGrid && grid) {
          grid.remove();
        }
      });

      console.log(`Grid ${showGrid ? 'enabled' : 'disabled'}`);
    };

    // Create grid overlay
    function createGrid(width, height) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.classList.add('grid-overlay');

      // Create grid lines every 20px
      for (let x = 0; x <= width; x += 20) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', height);
        line.setAttribute('stroke', '#999');
        line.setAttribute('stroke-width', x % 100 === 0 ? '2' : '0.5');
        svg.appendChild(line);
      }

      for (let y = 0; y <= height; y += 20) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', width);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#999');
        line.setAttribute('stroke-width', y % 100 === 0 ? '2' : '0.5');
        svg.appendChild(line);
      }

      return svg;
    }

    // Position analysis
    window.analyzePositions = function () {
      console.log('=== Position Analysis ===');

      const originalSvg = document.querySelector('#gauge-original svg');
      const newSvg = document.querySelector('#gauge-new svg');

      if (!originalSvg || !newSvg) {
        console.log('❌ SVG elements not found');
        return;
      }

      const analysis = document.getElementById('position-analysis');
      let report = '<h4>Detailed Element Comparison:</h4>';

      // Compare text elements (labels)
      const origTexts = originalSvg.querySelectorAll('text');
      const newTexts = newSvg.querySelectorAll('text');

      report += `<p><strong>Text Elements:</strong> Original: ${origTexts.length}, New: ${newTexts.length}</p>`;
      report += '<table border="1" cellpadding="5" style="width:100%; font-size:12px;"><tr><th>Element</th><th>Original</th><th>New</th><th>Difference</th></tr>';

      const maxTexts = Math.max(origTexts.length, newTexts.length);
      for (let i = 0; i < maxTexts; i++) {
        const origText = origTexts[i];
        const newText = newTexts[i];

        const origContent = origText ? origText.textContent : 'N/A';
        const newContent = newText ? newText.textContent : 'N/A';
        const origPos = origText ? `(${origText.getAttribute('x')}, ${origText.getAttribute('y')})` : 'N/A';
        const newPos = newText ? `(${newText.getAttribute('x')}, ${newText.getAttribute('y')})` : 'N/A';

        let diff = 'N/A';
        if (origText && newText) {
          const dx = parseFloat(newText.getAttribute('x')) - parseFloat(origText.getAttribute('x'));
          const dy = parseFloat(newText.getAttribute('y')) - parseFloat(origText.getAttribute('y'));
          diff = `Δx:${dx.toFixed(1)}, Δy:${dy.toFixed(1)}`;
        }

        const contentMatch = origContent === newContent;
        const rowColor = contentMatch ? 'white' : '#ffeeee';

        report += `<tr style="background:${rowColor}">
                    <td>Text ${i} "${origContent}"</td>
                    <td>${origPos}</td>
                    <td>${newPos}</td>
                    <td>${diff}</td>
                </tr>`;

        console.log(`Text ${i}: "${origContent}" vs "${newContent}" | ${origPos} vs ${newPos} | ${diff}`);
      }

      report += '</table>';

      // Compare path elements (gauge arcs)
      const origPaths = originalSvg.querySelectorAll('path');
      const newPaths = newSvg.querySelectorAll('path');

      report += `<p><strong>Path Elements:</strong> Original: ${origPaths.length}, New: ${newPaths.length}</p>`;

      if (origPaths.length > 0 && newPaths.length > 0) {
        report += '<h5>Path Data Comparison:</h5>';
        for (let i = 0; i < Math.min(origPaths.length, newPaths.length); i++) {
          const origPath = origPaths[i].getAttribute('d');
          const newPath = newPaths[i].getAttribute('d');
          const match = origPath === newPath;

          report += `<p><strong>Path ${i}:</strong> ${match ? '✅ Match' : '❌ Different'}</p>`;
          if (!match) {
            report += `<details><summary>Show path data</summary>
                            <p><strong>Original:</strong> ${origPath.substring(0, 100)}...</p>
                            <p><strong>New:</strong> ${newPath.substring(0, 100)}...</p>
                        </details>`;
          }
        }
      }

      analysis.innerHTML = report;
    };

    // Highlight differences
    function highlightDifferences() {
      // Remove existing highlights
      document.querySelectorAll('.diff-highlight').forEach(el => el.remove());

      const originalSvg = document.querySelector('#gauge-original svg');
      const newSvg = document.querySelector('#gauge-new svg');

      if (!originalSvg || !newSvg) return;

      const origTexts = originalSvg.querySelectorAll('text');
      const newTexts = newSvg.querySelectorAll('text');

      // Highlight text position differences
      for (let i = 0; i < Math.min(origTexts.length, newTexts.length); i++) {
        const origText = origTexts[i];
        const newText = newTexts[i];

        const origX = parseFloat(origText.getAttribute('x'));
        const origY = parseFloat(origText.getAttribute('y'));
        const newX = parseFloat(newText.getAttribute('x'));
        const newY = parseFloat(newText.getAttribute('y'));

        const dx = Math.abs(newX - origX);
        const dy = Math.abs(newY - origY);

        // If position differs by more than 2px, highlight
        if (dx > 2 || dy > 2) {
          highlightElement(newText, newText.parentElement);
          console.log(`Highlighted text "${newText.textContent}" - position difference: Δx:${dx.toFixed(1)}, Δy:${dy.toFixed(1)}`);
        }
      }
    }

    // Highlight element
    function highlightElement(element, container) {
      const rect = element.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      const highlight = document.createElement('div');
      highlight.classList.add('diff-highlight');
      highlight.style.left = (rect.left - containerRect.left - 5) + 'px';
      highlight.style.top = (rect.top - containerRect.top - 5) + 'px';
      highlight.style.width = (rect.width + 10) + 'px';
      highlight.style.height = (rect.height + 10) + 'px';

      container.appendChild(highlight);
    }

    // Export analysis
    window.exportComparison = function () {
      const analysis = document.getElementById('position-analysis').innerHTML;
      const consoleContent = document.getElementById('console-log').textContent;

      const exportData = {
        timestamp: new Date().toISOString(),
        gaugeParams: getCurrentGaugeParams(),
        analysis: analysis,
        console: consoleContent
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `justgage-comparison-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      console.log('Analysis exported successfully');
    };

    // Mouse tracking for coordinates
    document.addEventListener('mousemove', (e) => {
      const coordDisplay = document.getElementById('coordinate-display');
      if (showGrid) {
        coordDisplay.style.display = 'block';
        coordDisplay.textContent = `Mouse: (${e.clientX}, ${e.clientY})`;
      } else {
        coordDisplay.style.display = 'none';
      }
    });

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(async () => {
        try {
          await initializeGauges();
        } catch (error) {
          console.error('❌ Failed to initialize gauges:', error);
        }
      }, 100);
    });
  </script>
</body>

</html>
