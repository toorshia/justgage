<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JustGage Visual Diff Tool - Enhanced</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }

    .comparison-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }

    .gauge-section {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      flex: 1;
    }

    .gauge-title {
      text-align: center;
      margin-bottom: 15px;
      font-weight: bold;
      color: #333;
      font-size: 16px;
    }

    .gauge-container {
      position: relative;
      display: inline-block;
      border: 2px solid #ddd;
      background: #fafafa;
      transition: all 0.3s ease;
    }

    .overlay-container {
      position: relative;
      display: inline-block;
    }

    .overlay-gauge {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0.5;
    }

    .controls {
      margin: 20px 0;
      text-align: center;
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .controls button {
      margin: 5px;
      padding: 8px 15px;
      background: #007cba;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #005a8b;
    }

    .controls button.active {
      background: #ff6600;
    }

    .configuration-panel {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
      max-height: 500px;
      overflow-y: auto;
    }

    .config-section {
      margin-bottom: 20px;
      border: 1px solid #eee;
      border-radius: 5px;
      padding: 15px;
    }

    .config-section h3 {
      margin: 0 0 15px 0;
      color: #333;
      border-bottom: 2px solid #007cba;
      padding-bottom: 5px;
      cursor: pointer;
    }

    .config-section.collapsed .config-content {
      display: none;
    }

    .config-content {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
    }

    .input-group label {
      font-weight: bold;
      margin-bottom: 5px;
      color: #555;
    }

    .input-group input,
    .input-group select {
      padding: 5px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }

    .input-group input[type="range"] {
      width: 100%;
    }

    .color-input {
      width: 50px;
      height: 30px;
      padding: 0;
      border: none;
      cursor: pointer;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .size-controls {
      background: #fffacd;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: center;
    }

    .size-controls h3 {
      margin: 0 0 10px 0;
      color: #333;
    }

    .size-button {
      margin: 5px;
      padding: 10px 15px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }

    .size-button:hover {
      background: #218838;
    }

    .preset-buttons {
      background: #e8f4fd;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: center;
    }

    .preset-button {
      margin: 5px;
      padding: 8px 12px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .preset-button:hover {
      background: #545b62;
    }

    .analysis-panel {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
    }

    .diff-highlight {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid red;
      position: absolute;
      pointer-events: none;
    }

    .coordinate-display {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 1000;
    }

    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      opacity: 0.3;
    }

    #console-log {
      background: black;
      color: lime;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      height: 200px;
      overflow-y: auto;
      border-radius: 5px;
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <h1>JustGage Visual Diff Tool</h1>
  <p>Advanced visual comparison with overlay, grid, and precise positioning analysis</p>

  <div class="controls">
    <h3>Comparison Mode</h3>
    <button id="side-by-side" class="active" onclick="setMode('side-by-side')">Side by Side</button>
    <button id="overlay" onclick="setMode('overlay')">Overlay Mode</button>
    <button id="difference" onclick="setMode('difference')">Difference Highlight</button>

    <div style="margin: 15px 0;">
      <div class="input-group" style="display: inline-block; margin: 0 10px;">
        <label>New Gauge Opacity:</label>
        <input type="range" id="opacity-slider" min="0" max="100" value="50" oninput="adjustOpacity(this.value)">
        <span id="opacity-value">50%</span>
      </div>

      <div class="input-group" style="display: inline-block; margin: 0 10px;">
        <label>Test Value:</label>
        <input type="range" id="value-slider" min="0" max="100" value="67" oninput="updateValue(this.value)">
        <span id="value-display">67</span>
      </div>
    </div>
  </div>

  <!-- Size Testing Controls -->
  <div class="size-controls">
    <h3>üìè Responsive Testing Controls</h3>
    <p>Test relativeGaugeSize setting by changing container dimensions:</p>
    <button class="size-button" onclick="resizeContainers(0.5)">50% Size</button>
    <button class="size-button" onclick="resizeContainers(0.75)">75% Size</button>
    <button class="size-button" onclick="resizeContainers(1.0)">100% Size</button>
    <button class="size-button" onclick="resizeContainers(1.25)">125% Size</button>
    <button class="size-button" onclick="resizeContainers(1.5)">150% Size</button>
    <button class="size-button" onclick="animateResize()">üîÑ Animate Resize</button>
  </div>

  <!-- Configuration Presets -->
  <div class="preset-buttons">
    <h3>‚ö° Quick Presets</h3>
    <button class="preset-button" onclick="loadPreset('default')">Default</button>
    <button class="preset-button" onclick="loadPreset('donut')">Donut</button>
    <button class="preset-button" onclick="loadPreset('pointer')">Pointer</button>
    <button class="preset-button" onclick="loadPreset('differential')">Differential</button>
    <button class="preset-button" onclick="loadPreset('custom-sectors')">Custom Sectors</button>
    <button class="preset-button" onclick="loadPreset('minimal')">Minimal</button>
    <button class="preset-button" onclick="loadPreset('advanced')">Advanced</button>
  </div>

  <!-- Comprehensive Configuration Panel -->
  <div class="configuration-panel">
    <h2>üéõÔ∏è Complete Configuration Panel</h2>

    <!-- Basic Values -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üìä Basic Values</h3>
      <div class="config-content">
        <div class="input-group">
          <label>Value:</label>
          <input type="range" id="value-range" min="0" max="100" value="67"
            oninput="updateConfigValue('value', this.value)">
          <span id="value-text">67</span>
        </div>
        <div class="input-group">
          <label>Min:</label>
          <input type="number" id="min-input" value="0" onchange="updateConfigValue('min', this.value)">
        </div>
        <div class="input-group">
          <label>Max:</label>
          <input type="number" id="max-input" value="100" onchange="updateConfigValue('max', this.value)">
        </div>
        <div class="input-group">
          <label>Decimals:</label>
          <input type="number" id="decimals-input" value="0" min="0" max="5"
            onchange="updateConfigValue('decimals', this.value)">
        </div>
        <div class="input-group">
          <label>Symbol:</label>
          <input type="text" id="symbol-input" value="" onchange="updateConfigValue('symbol', this.value)">
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="reverse-checkbox" onchange="updateConfigValue('reverse', this.checked)">
          <label>Reverse</label>
        </div>
      </div>
    </div>

    <!-- Dimensions -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üìê Dimensions</h3>
      <div class="config-content">
        <div class="input-group">
          <label>Width:</label>
          <input type="number" id="width-input" value="400" min="100" max="800"
            onchange="updateConfigValue('width', this.value)">
        </div>
        <div class="input-group">
          <label>Height:</label>
          <input type="number" id="height-input" value="320" min="100" max="600"
            onchange="updateConfigValue('height', this.value)">
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="relative-size-checkbox"
            onchange="updateConfigValue('relativeGaugeSize', this.checked)">
          <label>Relative Gauge Size</label>
        </div>
        <div class="input-group">
          <label>Gauge Width Scale:</label>
          <input type="range" id="gauge-width-scale" min="0.5" max="2" step="0.1" value="1.0"
            oninput="updateConfigValue('gaugeWidthScale', this.value)">
          <span id="gauge-width-scale-text">1.0</span>
        </div>
      </div>
    </div>

    <!-- Colors -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üé® Colors</h3>
      <div class="config-content">
        <div class="input-group">
          <label>Gauge Color:</label>
          <input type="color" class="color-input" id="gauge-color" value="#edebeb"
            onchange="updateConfigValue('gaugeColor', this.value)">
        </div>
        <div class="input-group">
          <label>Value Font Color:</label>
          <input type="color" class="color-input" id="value-font-color" value="#010101"
            onchange="updateConfigValue('valueFontColor', this.value)">
        </div>
        <div class="input-group">
          <label>Label Font Color:</label>
          <input type="color" class="color-input" id="label-font-color" value="#b3b3b3"
            onchange="updateConfigValue('labelFontColor', this.value)">
        </div>
        <div class="input-group">
          <label>Level Colors:</label>
          <select id="level-colors-preset" onchange="updateLevelColors(this.value)">
            <option value="default">Default (Green-Yellow-Red)</option>
            <option value="blue">Blue Gradient</option>
            <option value="rainbow">Rainbow</option>
            <option value="single">Single Color</option>
          </select>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="no-gradient-checkbox" onchange="updateConfigValue('noGradient', this.checked)">
          <label>No Gradient</label>
        </div>
      </div>
    </div>

    <!-- Labels and Text -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üìù Labels and Text</h3>
      <div class="config-content">
        <div class="input-group">
          <label>Title:</label>
          <input type="text" id="title-input" value="" onchange="updateConfigValue('title', this.value)">
        </div>
        <div class="input-group">
          <label>Label:</label>
          <input type="text" id="label-input" value="units" onchange="updateConfigValue('label', this.value)">
        </div>
        <div class="input-group">
          <label>Min Text:</label>
          <input type="text" id="min-txt-input" value="" onchange="updateConfigValue('minTxt', this.value)">
        </div>
        <div class="input-group">
          <label>Max Text:</label>
          <input type="text" id="max-txt-input" value="" onchange="updateConfigValue('maxTxt', this.value)">
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="hide-value-checkbox" onchange="updateConfigValue('hideValue', this.checked)">
          <label>Hide Value</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="hide-min-max-checkbox" onchange="updateConfigValue('hideMinMax', this.checked)">
          <label>Hide Min/Max</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="human-friendly-checkbox"
            onchange="updateConfigValue('humanFriendly', this.checked)">
          <label>Human Friendly Numbers</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="format-number-checkbox" onchange="updateConfigValue('formatNumber', this.checked)">
          <label>Format Numbers</label>
        </div>
      </div>
    </div>

    <!-- Gauge Types -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">‚≠ï Gauge Types</h3>
      <div class="config-content">
        <div class="checkbox-group">
          <input type="checkbox" id="donut-checkbox" onchange="updateConfigValue('donut', this.checked)">
          <label>Donut Mode</label>
        </div>
        <div class="input-group">
          <label>Donut Start Angle:</label>
          <input type="range" id="donut-start-angle" min="0" max="360" value="90"
            oninput="updateConfigValue('donutStartAngle', this.value)">
          <span id="donut-start-angle-text">90¬∞</span>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="differential-checkbox" onchange="updateConfigValue('differential', this.checked)">
          <label>Differential</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="display-remaining-checkbox"
            onchange="updateConfigValue('displayRemaining', this.checked)">
          <label>Display Remaining</label>
        </div>
      </div>
    </div>

    <!-- Pointer -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üëâ Pointer</h3>
      <div class="config-content">
        <div class="checkbox-group">
          <input type="checkbox" id="pointer-checkbox" onchange="updateConfigValue('pointer', this.checked)">
          <label>Show Pointer</label>
        </div>
        <div class="input-group">
          <label>Pointer Color:</label>
          <input type="color" class="color-input" id="pointer-color" value="#8e2de2"
            onchange="updatePointerOption('color', this.value)">
        </div>
        <div class="input-group">
          <label>Top Length:</label>
          <input type="number" id="pointer-top-length" value="14"
            onchange="updatePointerOption('toplength', this.value)">
        </div>
        <div class="input-group">
          <label>Bottom Length:</label>
          <input type="number" id="pointer-bottom-length" value="27"
            onchange="updatePointerOption('bottomlength', this.value)">
        </div>
        <div class="input-group">
          <label>Bottom Width:</label>
          <input type="number" id="pointer-bottom-width" value="4"
            onchange="updatePointerOption('bottomwidth', this.value)">
        </div>
      </div>
    </div>

    <!-- Target Line -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üéØ Target Line</h3>
      <div class="config-content">
        <div class="checkbox-group">
          <input type="checkbox" id="target-line-checkbox" onchange="toggleTargetLine(this.checked)">
          <label>Show Target Line</label>
        </div>
        <div class="input-group">
          <label>Target Value:</label>
          <input type="number" id="target-line-value" value="75" onchange="updateConfigValue('targetLine', this.value)">
        </div>
        <div class="input-group">
          <label>Target Color:</label>
          <input type="color" class="color-input" id="target-line-color" value="#000000"
            onchange="updateConfigValue('targetLineColor', this.value)">
        </div>
        <div class="input-group">
          <label>Target Width:</label>
          <input type="range" id="target-line-width" min="0.5" max="5" step="0.5" value="1.5"
            oninput="updateConfigValue('targetLineWidth', this.value)">
          <span id="target-line-width-text">1.5</span>
        </div>
      </div>
    </div>

    <!-- Animation -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üé¨ Animation</h3>
      <div class="config-content">
        <div class="input-group">
          <label>Start Animation Time:</label>
          <input type="range" id="start-animation-time" min="0" max="3000" value="700"
            oninput="updateConfigValue('startAnimationTime', this.value)">
          <span id="start-animation-time-text">700ms</span>
        </div>
        <div class="input-group">
          <label>Start Animation Type:</label>
          <select id="start-animation-type" onchange="updateConfigValue('startAnimationType', this.value)">
            <option value="linear">Linear</option>
            <option value=">" selected>Ease Out</option>
            <option value="<">Ease In</option>
            <option value="<>">Ease In-Out</option>
            <option value="bounce">Bounce</option>
          </select>
        </div>
        <div class="input-group">
          <label>Refresh Animation Time:</label>
          <input type="range" id="refresh-animation-time" min="0" max="3000" value="700"
            oninput="updateConfigValue('refreshAnimationTime', this.value)">
          <span id="refresh-animation-time-text">700ms</span>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="counter-checkbox" onchange="updateConfigValue('counter', this.checked)">
          <label>Counter Animation</label>
        </div>
      </div>
    </div>

    <!-- Shadow -->
    <div class="config-section">
      <h3 onclick="toggleSection(this)">üåö Shadow</h3>
      <div class="config-content">
        <div class="checkbox-group">
          <input type="checkbox" id="show-inner-shadow-checkbox"
            onchange="updateConfigValue('showInnerShadow', this.checked)">
          <label>Show Inner Shadow</label>
        </div>
        <div class="input-group">
          <label>Shadow Opacity:</label>
          <input type="range" id="shadow-opacity" min="0" max="1" step="0.1" value="0.2"
            oninput="updateConfigValue('shadowOpacity', this.value)">
          <span id="shadow-opacity-text">0.2</span>
        </div>
        <div class="input-group">
          <label>Shadow Size:</label>
          <input type="range" id="shadow-size" min="0" max="20" value="5"
            oninput="updateConfigValue('shadowSize', this.value)">
          <span id="shadow-size-text">5</span>
        </div>
        <div class="input-group">
          <label>Shadow Vertical Offset:</label>
          <input type="range" id="shadow-vertical-offset" min="0" max="20" value="3"
            oninput="updateConfigValue('shadowVerticalOffset', this.value)">
          <span id="shadow-vertical-offset-text">3</span>
        </div>
      </div>
    </div>
  </div>
  </div>
  <div>
    <label>Title Font Size:</label>
    <input type="number" id="title-font-size" value="24" min="10" max="40" onchange="updateConfig()"
      style="width: 60px;">
  </div>
  <div>
    <label>Label Font Size:</label>
    <input type="number" id="label-font-size" value="11" min="8" max="20" onchange="updateConfig()"
      style="width: 60px;">
  </div>
  <div>
    <label>Gauge Width Scale:</label>
    <input type="number" id="gauge-width-scale" value="1" min="0.5" max="2" step="0.1" onchange="updateConfig()"
      style="width: 60px;">
  </div>
  </div>

  <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 10px;">
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="show-inner-shadow" onchange="updateConfig()"> Inner Shadow
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="no-gradient" onchange="updateConfig()"> No Gradient
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="reverse" onchange="updateConfig()"> Reverse
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="start-animation" checked onchange="updateConfig()"> Start Animation
    </label>
  </div>

  <div style="margin: 15px 0;">
    <button onclick="toggleGrid()">Toggle Grid</button>
    <button onclick="analyzePositions()">Analyze Positions</button>
    <button onclick="exportComparison()">Export Analysis</button>
    <button onclick="resetToDefaults()">Reset to Defaults</button>
  </div>
  </div>

  <div id="comparison-area">
    <div class="comparison-container">
      <div class="gauge-section">
        <div class="gauge-title">Original JustGage (Reference)</div>
        <div class="gauge-container" id="original-container">
          <div id="gauge-original" style="width: 400px; height: 320px;"></div>
        </div>
      </div>

      <div class="gauge-section">
        <div class="gauge-title">New JustGage (Testing)</div>
        <div class="gauge-container" id="new-container">
          <div id="gauge-new" style="width: 400px; height: 320px;"></div>
        </div>
      </div>
    </div>

    <div id="overlay-section" style="display: none;">
      <div class="gauge-section">
        <div class="gauge-title">Overlay Comparison</div>
        <div class="overlay-container" id="overlay-container">
          <div id="gauge-base" style="width: 400px; height: 320px;"></div>
          <div id="gauge-overlay" class="overlay-gauge" style="width: 400px; height: 320px;"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="analysis-panel">
    <h3>Position Analysis</h3>
    <div id="position-analysis"></div>
    <div id="console-log"></div>
  </div>

  <div class="coordinate-display" id="coordinate-display" style="display: none;">
    Mouse: (0, 0)
  </div>

  <!-- Original JustGage -->
  <script src="../raphael.min.js"></script>
  <script src="../justgage.js"></script>

  <!-- New JustGage -->
  <script type="module">

    // Global state
    let currentMode = 'side-by-side';
    let originalGauge, newGauge, baseGauge, overlayGauge;
    let showGrid = false;
    const OldJustGage = JustGage; // Original JustGage, prevent override when loading new

    let NewJustGage = null

    // Console logging
    const consoleLog = document.getElementById('console-log');
    const originalLog = console.log;
    console.log = function (...args) {
      originalLog.apply(console, args);
      const line = new Date().toLocaleTimeString() + ': ' + args.join(' ') + '\n';
      if (consoleLog) {
        consoleLog.textContent += line;
        consoleLog.scrollTop = consoleLog.scrollHeight;
      }
    };

    // Configuration state
    let currentConfig = {
      value: 67,
      min: 0,
      max: 100,
      decimals: 0,
      symbol: '',
      reverse: false,
      width: 400,
      height: 320,
      relativeGaugeSize: false,
      gaugeWidthScale: 1.0,
      gaugeColor: '#edebeb',
      valueFontColor: '#010101',
      labelFontColor: '#b3b3b3',
      levelColors: ['#a9d70b', '#f9c802', '#ff0000'],
      noGradient: false,
      title: '',
      label: 'units',
      minTxt: '',
      maxTxt: '',
      hideValue: false,
      hideMinMax: false,
      humanFriendly: false,
      formatNumber: false,
      donut: false,
      donutStartAngle: 90,
      differential: false,
      displayRemaining: false,
      pointer: false,
      pointerOptions: {
        color: '#8e2de2',
        toplength: 14,
        bottomlength: 27,
        bottomwidth: 4
      },
      targetLine: null,
      targetLineColor: '#000000',
      targetLineWidth: 1.5,
      startAnimationTime: 700,
      startAnimationType: '>',
      refreshAnimationTime: 700,
      counter: false,
      showInnerShadow: false,
      shadowOpacity: 0.2,
      shadowSize: 5,
      shadowVerticalOffset: 3
    };

    // Get current gauge parameters from configuration
    function getCurrentGaugeParams() {
      return { ...currentConfig };
    }

    // Update configuration value
    window.updateConfigValue = function (key, value) {
      // Handle type conversion
      if (typeof currentConfig[key] === 'number') {
        value = parseFloat(value);
      } else if (typeof currentConfig[key] === 'boolean') {
        value = Boolean(value);
      }

      currentConfig[key] = value;

      // Update UI display elements
      updateDisplayValues();

      // Recreate gauges with new configuration
      setTimeout(() => recreateGauges(), 100);
    };

    // Update pointer options
    window.updatePointerOption = function (key, value) {
      if (!currentConfig.pointerOptions) {
        currentConfig.pointerOptions = {};
      }
      currentConfig.pointerOptions[key] = parseFloat(value) || value;
      setTimeout(() => recreateGauges(), 100);
    };

    // Toggle target line
    window.toggleTargetLine = function (enabled) {
      if (enabled) {
        currentConfig.targetLine = parseFloat(document.getElementById('target-line-value').value);
      } else {
        currentConfig.targetLine = null;
      }
      setTimeout(() => recreateGauges(), 100);
    };

    // Update level colors based on preset
    window.updateLevelColors = function (preset) {
      switch (preset) {
        case 'blue':
          currentConfig.levelColors = ['#0066cc', '#0099ff', '#00ccff'];
          break;
        case 'rainbow':
          currentConfig.levelColors = ['#ff0000', '#ff6600', '#ffcc00', '#66ff00', '#00ff66', '#0066ff'];
          break;
        case 'single':
          currentConfig.levelColors = ['#ff6600'];
          break;
        default:
          currentConfig.levelColors = ['#a9d70b', '#f9c802', '#ff0000'];
      }
      setTimeout(() => recreateGauges(), 100);
    };

    // Update display values in UI
    function updateDisplayValues() {
      document.getElementById('value-text').textContent = currentConfig.value;
      document.getElementById('value-range').value = currentConfig.value;
      document.getElementById('value-display').textContent = currentConfig.value;
      document.getElementById('value-slider').value = currentConfig.value;

      document.getElementById('gauge-width-scale-text').textContent = currentConfig.gaugeWidthScale;
      document.getElementById('donut-start-angle-text').textContent = currentConfig.donutStartAngle + '¬∞';
      document.getElementById('target-line-width-text').textContent = currentConfig.targetLineWidth;
      document.getElementById('start-animation-time-text').textContent = currentConfig.startAnimationTime + 'ms';
      document.getElementById('refresh-animation-time-text').textContent = currentConfig.refreshAnimationTime + 'ms';
      document.getElementById('shadow-opacity-text').textContent = currentConfig.shadowOpacity;
      document.getElementById('shadow-size-text').textContent = currentConfig.shadowSize;
      document.getElementById('shadow-vertical-offset-text').textContent = currentConfig.shadowVerticalOffset;
    }

    // Load configuration presets
    window.loadPreset = function (preset) {
      switch (preset) {
        case 'donut':
          Object.assign(currentConfig, {
            donut: true,
            donutStartAngle: 90,
            hideMinMax: true,
            value: 75,
            label: 'Progress',
            levelColors: ['#00ff66', '#ffcc00', '#ff3300']
          });
          break;

        case 'pointer':
          Object.assign(currentConfig, {
            pointer: true,
            donut: false,
            value: 60,
            label: 'Speed',
            pointerOptions: {
              color: '#8e2de2',
              toplength: 20,
              bottomlength: 30,
              bottomwidth: 6
            }
          });
          break;

        case 'differential':
          Object.assign(currentConfig, {
            differential: true,
            min: -50,
            max: 50,
            value: 25,
            label: 'Differential',
            levelColors: ['#ff0000', '#ffff00', '#00ff00']
          });
          break;

        case 'custom-sectors':
          Object.assign(currentConfig, {
            noGradient: true,
            levelColors: ['#ff0000', '#ff6600', '#ffcc00', '#66ff00', '#00ff66'],
            value: 80,
            label: 'Custom'
          });
          break;

        case 'minimal':
          Object.assign(currentConfig, {
            hideMinMax: true,
            title: '',
            label: '',
            showInnerShadow: false,
            levelColors: ['#999999']
          });
          break;

        case 'advanced':
          Object.assign(currentConfig, {
            pointer: true,
            targetLine: 75,
            showInnerShadow: true,
            counter: true,
            humanFriendly: true,
            title: 'Advanced Gauge',
            label: 'Performance'
          });
          break;

        default: // 'default'
          currentConfig = {
            value: 67,
            min: 0,
            max: 100,
            decimals: 0,
            symbol: '',
            reverse: false,
            width: 400,
            height: 320,
            relativeGaugeSize: false,
            gaugeWidthScale: 1.0,
            gaugeColor: '#edebeb',
            valueFontColor: '#010101',
            labelFontColor: '#b3b3b3',
            levelColors: ['#a9d70b', '#f9c802', '#ff0000'],
            noGradient: false,
            title: '',
            label: 'units',
            minTxt: '',
            maxTxt: '',
            hideValue: false,
            hideMinMax: false,
            humanFriendly: false,
            formatNumber: false,
            donut: false,
            donutStartAngle: 90,
            differential: false,
            displayRemaining: false,
            pointer: false,
            pointerOptions: {
              color: '#8e2de2',
              toplength: 14,
              bottomlength: 27,
              bottomwidth: 4
            },
            targetLine: null,
            targetLineColor: '#000000',
            targetLineWidth: 1.5,
            startAnimationTime: 700,
            startAnimationType: '>',
            refreshAnimationTime: 700,
            counter: false,
            showInnerShadow: false,
            shadowOpacity: 0.2,
            shadowSize: 5,
            shadowVerticalOffset: 3
          };
      }

      // Update UI controls to match preset
      syncUIWithConfig();
      setTimeout(() => recreateGauges(), 100);
    };

    // Sync UI controls with current configuration
    function syncUIWithConfig() {
      // Update all input elements to match current config
      Object.keys(currentConfig).forEach(key => {
        const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase() + '-input') ||
          document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase() + '-checkbox') ||
          document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());

        if (element) {
          if (element.type === 'checkbox') {
            element.checked = currentConfig[key];
          } else if (element.type === 'color') {
            element.value = currentConfig[key];
          } else {
            element.value = currentConfig[key];
          }
        }
      });

      updateDisplayValues();
    }

    // Resize containers for responsive testing
    window.resizeContainers = function (scale) {
      const containers = document.querySelectorAll('.gauge-container');
      containers.forEach(container => {
        const baseWidth = currentConfig.width;
        const baseHeight = currentConfig.height;

        container.style.width = (baseWidth * scale) + 'px';
        container.style.height = (baseHeight * scale) + 'px';
        container.style.transform = `scale(${scale})`;
        container.style.transformOrigin = 'top left';
      });

      console.log(`Resized containers to ${(scale * 100)}% scale`);
    };

    // Animate resize for testing
    window.animateResize = function () {
      let scale = 0.5;
      const direction = 1;

      const animate = () => {
        resizeContainers(scale);
        scale += 0.05;

        if (scale <= 1.5) {
          setTimeout(animate, 200);
        } else {
          // Reset to normal
          setTimeout(() => resizeContainers(1.0), 500);
        }
      };

      animate();
    };

    // Toggle configuration sections
    window.toggleSection = function (header) {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
    };        // Initialize gauges
    async function initializeGauges() {
      console.log('Initializing gauges for visual comparison...');

      try {
        // Ensure RaphaelJS is available for original gauge
        if (typeof Raphael === 'undefined') {
          console.log('‚ùå RaphaelJS not available for original gauge');
          return;
        }


        // Create original gauge (RaphaelJS version) - without explicit dimensions
        const originalParams = getCurrentGaugeParams();
        console.log('üìä Original gauge params:', originalParams);
        originalGauge = new OldJustGage({
          id: "gauge-original",
          ...originalParams
        });
        console.log('‚úÖ Original gauge created:', originalGauge);

        // Import the new JustGage implementation if not already imported
        if (!NewJustGage) {
          NewJustGage = (await import('../dist/justgage.esm.js')).JustGage;

          console.log('‚úÖ New JustGage implementation imported');
        }

        console.log(OldJustGage !== NewJustGage ? '‚úÖ Different JustGage classes confirmed' : '‚ùå JustGage classes are the same!');

        // Create new gauge (modern version) - with explicit dimensions
        const newParams = {
          ...getCurrentGaugeParams(),
          width: parseInt(document.getElementById('width-input').value),
          height: parseInt(document.getElementById('height-input').value)
        };
        console.log('üìä New gauge params:', newParams);
        newGauge = new NewJustGage({
          parentNode: document.getElementById('gauge-new'),
          ...newParams
        });
        console.log('‚úÖ New gauge created:', newGauge);

        // Create base and overlay gauges for overlay mode
        const baseParams = getCurrentGaugeParams();
        baseGauge = new OldJustGage({
          id: 'gauge-base',
          ...baseParams
        });

        const overlayParams = {
          ...getCurrentGaugeParams(),
          width: parseInt(document.getElementById('width-input').value),
          height: parseInt(document.getElementById('height-input').value)
        };
        overlayGauge = new NewJustGage({
          parentNode: document.getElementById('gauge-overlay'),
          ...overlayParams
        });
        console.log('‚úÖ Overlay gauges created');

        console.log('‚úÖ All gauges initialized successfully');

        // Initial analysis
        setTimeout(() => analyzePositions(), 1000);

      } catch (error) {
        console.log('‚ùå Error initializing gauges:', error.message);
        console.log('Stack:', error.stack);
      }
    }    // Mode switching
    window.setMode = function (mode) {
      currentMode = mode;

      // Update button states
      document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
      document.getElementById(mode).classList.add('active');

      // Show/hide sections
      const comparisonContainer = document.querySelector('.comparison-container');
      const overlaySection = document.getElementById('overlay-section');

      switch (mode) {
        case 'side-by-side':
          comparisonContainer.style.display = 'flex';
          overlaySection.style.display = 'none';
          break;
        case 'overlay':
          comparisonContainer.style.display = 'none';
          overlaySection.style.display = 'block';
          break;
        case 'difference':
          comparisonContainer.style.display = 'flex';
          overlaySection.style.display = 'none';
          highlightDifferences();
          break;
      }

      console.log(`Switched to ${mode} mode`);
    };

    // Update value from slider
    window.updateValue = function (value) {
      currentConfig.value = parseInt(value);
      updateDisplayValues();

      // Update gauges if they exist
      if (originalGauge && originalGauge.refresh) {
        originalGauge.refresh(currentConfig.value);
      }
      if (newGauge && newGauge.refresh) {
        newGauge.refresh(currentConfig.value);
      }
      if (baseGauge && baseGauge.refresh) {
        baseGauge.refresh(currentConfig.value);
      }
      if (overlayGauge && overlayGauge.refresh) {
        overlayGauge.refresh(currentConfig.value);
      }

      // Update analysis
      setTimeout(() => analyzePositions(), 500);
    };

    // Configuration update (legacy function for compatibility)
    window.updateConfig = async function () {
      console.log('üîÑ Updating gauge configuration...');
      await recreateGauges();
    };

    // Recreate all gauges with current settings
    async function recreateGauges() {
      // Clear existing gauges
      clearGauges();

      // Recreate with new parameters
      setTimeout(async () => {
        try {
          await initializeGauges();
        } catch (error) {
          console.error('‚ùå Error recreating gauges:', error);
        }
      }, 100);
    }

    // Clear existing gauges
    function clearGauges() {
      console.log('üßπ Clearing existing gauges...');

      // Properly destroy gauge instances if they have destroy methods
      if (originalGauge && typeof originalGauge.destroy === 'function') {
        try {
          originalGauge.destroy();
          console.log('‚úÖ Original gauge destroyed');
        } catch (e) {
          console.log('‚ö†Ô∏è Error destroying original gauge:', e);
        }
      }

      if (newGauge && typeof newGauge.destroy === 'function') {
        try {
          newGauge.destroy();
          console.log('‚úÖ New gauge destroyed');
        } catch (e) {
          console.log('‚ö†Ô∏è Error destroying new gauge:', e);
        }
      }

      if (baseGauge && typeof baseGauge.destroy === 'function') {
        try {
          baseGauge.destroy();
          console.log('‚úÖ Base gauge destroyed');
        } catch (e) {
          console.log('‚ö†Ô∏è Error destroying base gauge:', e);
        }
      }

      if (overlayGauge && typeof overlayGauge.destroy === 'function') {
        try {
          overlayGauge.destroy();
          console.log('‚úÖ Overlay gauge destroyed');
        } catch (e) {
          console.log('‚ö†Ô∏è Error destroying overlay gauge:', e);
        }
      }

      // Clear DOM containers
      const containers = ['gauge-original', 'gauge-new', 'gauge-base', 'gauge-overlay'];
      containers.forEach(id => {
        const container = document.getElementById(id);
        if (container) {
          container.innerHTML = '';
          console.log(`‚úÖ Cleared container: ${id}`);
        }
      });

      // Reset gauge references
      originalGauge = newGauge = baseGauge = overlayGauge = null;
      console.log('‚úÖ All gauge references reset');
    }

    // Reset to defaults
    window.resetToDefaults = function () {
      document.getElementById('value-slider').value = 67;
      document.getElementById('min-slider').value = 0;
      document.getElementById('max-slider').value = 100;
      document.getElementById('width-input').value = 400;
      document.getElementById('height-input').value = 320;
      document.getElementById('title-input').value = 'Test Gauge';
      document.getElementById('label-input').value = 'units';
      document.getElementById('target-input').value = 75;

      document.getElementById('show-title').checked = true;
      document.getElementById('show-label').checked = true;
      document.getElementById('show-minmax').checked = true;
      document.getElementById('show-pointer').checked = false;
      document.getElementById('show-target').checked = false;
      document.getElementById('donut-mode').checked = false;

      // Update displays
      document.getElementById('value-display').textContent = '67';
      document.getElementById('min-display').textContent = '0';
      document.getElementById('max-display').textContent = '100';

      recreateGauges();
    };    // Opacity adjustment
    window.adjustOpacity = function (value) {
      document.getElementById('opacity-value').textContent = value + '%';
      const overlayGauge = document.getElementById('gauge-overlay');
      if (overlayGauge) {
        overlayGauge.style.opacity = value / 100;
      }
    };

    // Value update
    window.updateValue = function (value) {
      document.getElementById('value-display').textContent = value;

      // Update all gauges
      if (originalGauge && originalGauge.refresh) originalGauge.refresh(value);
      if (newGauge && newGauge.refresh) newGauge.refresh(value);
      if (baseGauge && baseGauge.refresh) baseGauge.refresh(value);
      if (overlayGauge && overlayGauge.refresh) overlayGauge.refresh(value);

      // Re-analyze after update
      setTimeout(() => analyzePositions(), 500);
    };

    // Grid toggle
    window.toggleGrid = function () {
      showGrid = !showGrid;
      const containers = document.querySelectorAll('.gauge-container, .overlay-container');

      containers.forEach(container => {
        let grid = container.querySelector('.grid-overlay');
        if (showGrid && !grid) {
          grid = createGrid(400, 320);
          container.appendChild(grid);
        } else if (!showGrid && grid) {
          grid.remove();
        }
      });

      console.log(`Grid ${showGrid ? 'enabled' : 'disabled'}`);
    };

    // Create grid overlay
    function createGrid(width, height) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.classList.add('grid-overlay');

      // Create grid lines every 20px
      for (let x = 0; x <= width; x += 20) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', height);
        line.setAttribute('stroke', '#999');
        line.setAttribute('stroke-width', x % 100 === 0 ? '2' : '0.5');
        svg.appendChild(line);
      }

      for (let y = 0; y <= height; y += 20) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', width);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#999');
        line.setAttribute('stroke-width', y % 100 === 0 ? '2' : '0.5');
        svg.appendChild(line);
      }

      return svg;
    }

    // Position analysis
    window.analyzePositions = function () {
      console.log('=== Position Analysis ===');

      const originalSvg = document.querySelector('#gauge-original svg');
      const newSvg = document.querySelector('#gauge-new svg');

      if (!originalSvg || !newSvg) {
        console.log('‚ùå SVG elements not found');
        return;
      }

      const analysis = document.getElementById('position-analysis');
      let report = '<h4>Detailed Element Comparison:</h4>';

      // Compare text elements (labels)
      const origTexts = originalSvg.querySelectorAll('text');
      const newTexts = newSvg.querySelectorAll('text');

      report += `<p><strong>Text Elements:</strong> Original: ${origTexts.length}, New: ${newTexts.length}</p>`;
      report += '<table border="1" cellpadding="5" style="width:100%; font-size:12px;"><tr><th>Element</th><th>Original</th><th>New</th><th>Difference</th></tr>';

      const maxTexts = Math.max(origTexts.length, newTexts.length);
      for (let i = 0; i < maxTexts; i++) {
        const origText = origTexts[i];
        const newText = newTexts[i];

        const origContent = origText ? origText.textContent : 'N/A';
        const newContent = newText ? newText.textContent : 'N/A';
        const origPos = origText ? `(${origText.getAttribute('x')}, ${origText.getAttribute('y')})` : 'N/A';
        const newPos = newText ? `(${newText.getAttribute('x')}, ${newText.getAttribute('y')})` : 'N/A';

        let diff = 'N/A';
        if (origText && newText) {
          const dx = parseFloat(newText.getAttribute('x')) - parseFloat(origText.getAttribute('x'));
          const dy = parseFloat(newText.getAttribute('y')) - parseFloat(origText.getAttribute('y'));
          diff = `Œîx:${dx.toFixed(1)}, Œîy:${dy.toFixed(1)}`;
        }

        const contentMatch = origContent === newContent;
        const rowColor = contentMatch ? 'white' : '#ffeeee';

        report += `<tr style="background:${rowColor}">
                    <td>Text ${i} "${origContent}"</td>
                    <td>${origPos}</td>
                    <td>${newPos}</td>
                    <td>${diff}</td>
                </tr>`;

        console.log(`Text ${i}: "${origContent}" vs "${newContent}" | ${origPos} vs ${newPos} | ${diff}`);
      }

      report += '</table>';

      // Compare path elements (gauge arcs)
      const origPaths = originalSvg.querySelectorAll('path');
      const newPaths = newSvg.querySelectorAll('path');

      report += `<p><strong>Path Elements:</strong> Original: ${origPaths.length}, New: ${newPaths.length}</p>`;

      if (origPaths.length > 0 && newPaths.length > 0) {
        report += '<h5>Path Data Comparison:</h5>';
        for (let i = 0; i < Math.min(origPaths.length, newPaths.length); i++) {
          const origPath = origPaths[i].getAttribute('d');
          const newPath = newPaths[i].getAttribute('d');
          const match = origPath === newPath;

          report += `<p><strong>Path ${i}:</strong> ${match ? '‚úÖ Match' : '‚ùå Different'}</p>`;
          if (!match) {
            report += `<details><summary>Show path data</summary>
                            <p><strong>Original:</strong> ${origPath.substring(0, 100)}...</p>
                            <p><strong>New:</strong> ${newPath.substring(0, 100)}...</p>
                        </details>`;
          }
        }
      }

      analysis.innerHTML = report;
    };

    // Highlight differences
    function highlightDifferences() {
      // Remove existing highlights
      document.querySelectorAll('.diff-highlight').forEach(el => el.remove());

      const originalSvg = document.querySelector('#gauge-original svg');
      const newSvg = document.querySelector('#gauge-new svg');

      if (!originalSvg || !newSvg) return;

      const origTexts = originalSvg.querySelectorAll('text');
      const newTexts = newSvg.querySelectorAll('text');

      // Highlight text position differences
      for (let i = 0; i < Math.min(origTexts.length, newTexts.length); i++) {
        const origText = origTexts[i];
        const newText = newTexts[i];

        const origX = parseFloat(origText.getAttribute('x'));
        const origY = parseFloat(origText.getAttribute('y'));
        const newX = parseFloat(newText.getAttribute('x'));
        const newY = parseFloat(newText.getAttribute('y'));

        const dx = Math.abs(newX - origX);
        const dy = Math.abs(newY - origY);

        // If position differs by more than 2px, highlight
        if (dx > 2 || dy > 2) {
          highlightElement(newText, newText.parentElement);
          console.log(`Highlighted text "${newText.textContent}" - position difference: Œîx:${dx.toFixed(1)}, Œîy:${dy.toFixed(1)}`);
        }
      }
    }

    // Highlight element
    function highlightElement(element, container) {
      const rect = element.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      const highlight = document.createElement('div');
      highlight.classList.add('diff-highlight');
      highlight.style.left = (rect.left - containerRect.left - 5) + 'px';
      highlight.style.top = (rect.top - containerRect.top - 5) + 'px';
      highlight.style.width = (rect.width + 10) + 'px';
      highlight.style.height = (rect.height + 10) + 'px';

      container.appendChild(highlight);
    }

    // Export analysis
    window.exportComparison = function () {
      const analysis = document.getElementById('position-analysis').innerHTML;
      const consoleContent = document.getElementById('console-log').textContent;

      const exportData = {
        timestamp: new Date().toISOString(),
        gaugeParams: getCurrentGaugeParams(),
        analysis: analysis,
        console: consoleContent
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `justgage-comparison-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      console.log('Analysis exported successfully');
    };

    // Mouse tracking for coordinates
    document.addEventListener('mousemove', (e) => {
      const coordDisplay = document.getElementById('coordinate-display');
      if (showGrid) {
        coordDisplay.style.display = 'block';
        coordDisplay.textContent = `Mouse: (${e.clientX}, ${e.clientY})`;
      } else {
        coordDisplay.style.display = 'none';
      }
    });

    // Adjust overlay opacity
    window.adjustOpacity = function (value) {
      const overlayGauge = document.getElementById('gauge-overlay');
      if (overlayGauge) {
        overlayGauge.style.opacity = value / 100;
      }
      document.getElementById('opacity-value').textContent = value + '%';
    };

    // Toggle grid overlay
    window.toggleGrid = function () {
      showGrid = !showGrid;

      const containers = document.querySelectorAll('.gauge-container');
      containers.forEach(container => {
        const existingGrid = container.querySelector('.grid-overlay');
        if (existingGrid) {
          existingGrid.remove();
        }

        if (showGrid) {
          const grid = createGrid(400, 320);
          grid.classList.add('grid-overlay');
          container.appendChild(grid);
        }
      });

      console.log(showGrid ? 'Grid enabled' : 'Grid disabled');
    };

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Sync UI with initial configuration
      syncUIWithConfig();

      setTimeout(async () => {
        try {
          await initializeGauges();
        } catch (error) {
          console.error('‚ùå Failed to initialize gauges:', error);
        }
      }, 100);
    });
  </script>
</body>

</html>
